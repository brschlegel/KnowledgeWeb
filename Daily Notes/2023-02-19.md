## Programming and Thinking too hard
---
There's almost a default way of thinking that I've developed for game development and programming in general. When I was trying to get deeper into C++ and get some more familiarity with the language, I commented that I would often just try to "translate" from C# into C++, with mixed results. On the one hand, it was a jumping off point to actually start doing things rather than sitting around thinking about them all the time, but also, why not just use C# then? You aren't getting all the benefits of using a different language like that. I think this sort of got mitigated as I used C++ more and more, but definitely never got to the point where I was comfortable with a "C++ framework" in how I did my work.
## Godot
---
I've been trying out [[General Thoughts |Godot]] recently as part of my independent study, and its been feeling pretty similar. I know how I would do all these things in Unity, and its frustrating to struggle with seemingly simple things. In fact, this is why I stopped using Godot last time; I was trying to use it for an AI project but I was struggling too much with the basics. Granted, I was on a bit of a time crunch as I had a grade to earn. Especially with Godot I have been getting stuck in this [[Analysis Paralysis]] trying to figure out the super correct best way of doing things. Instead, my focus should really be about making things, and seeing how they succeed or fail.
### Thinking hard
All of this thinking is definitely useful in many ways. During capstone, thinking hard about the way our program is structured has lead to some great systems. The [[When Push Comes to Shove#Development#Hitboxes and Hurtboxes|Hitbox System]] wasn't something I had really delved into before, it was a product of thoughts about centralizing data, flexibility, and composition. On the other hand, the [[When Push Comes to Shove#Animations|Animation System]] was born out of a bunch of frustration dealing with an enemy (which were cut!) being in a bunch of different states at once. I didn't recognize my needs or fully understand the problems until I dug in. Part of that could have been that a hitbox system is more general, while the approach I was taking to the enemy system was pretty game specific. Either way though I needed to start working to recognize that I needed to step back and take a wider and more structural approach. That approach was informed by both the problems I was encountering, and my knowledge of Unity's systems
## Project Permanence 
---
In general I think there is a lesson here in how I treat projects. Pretty much all of my projects have been games, which kinda by definition don't have a real end point, especially for the amount of time I put into them. All of my projects are assumed to be super long term in my mind, and as such I try to future proof them as much as possible. This has been very helpful in [[MultiMouse]] and [[When Push Comes to Shove]], but inside of those projects, rewritting has happened and has been a good thing. Especially now, when no grades are on the line, projects don't have a minimum or fixed length of one semester, and these projects are no longer my primary recruiting potential, it is super ok just to get things working at first. Chances are, these projects won't last that long as I find the idea isn't as interesting as I thought, or I just tire of making it. Projects also don't have to be super long or fully fledged games anymore! They can be tiny experiments, like trying to make a behavior tree in Godot or a cellular automata.
